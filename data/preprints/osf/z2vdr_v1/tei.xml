<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sound Notional Machines</title>
				<funder ref="#_4kvt49B">
					<orgName type="full">Swiss National Science Foundation</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Igor</forename><forename type="middle">Moreno</forename><surname>Santos</surname></persName>
							<email>igor.moreno.santos@usi.ch</email>
						</author>
						<author>
							<persName><forename type="first">Johan</forename><surname>Jeuring</surname></persName>
							<email>j.t.jeuring@uu.nl</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Università della Svizzera italiana Lugano</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University</orgName>
								<address>
									<country>The</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sound Notional Machines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">B233512825F5167609E27C54380070B1</idno>
					<idno type="DOI">10.5281/zenodo.12609636</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.0" ident="GROBID" when="2025-10-22T02:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>notional machines</term>
					<term>programming education</term>
					<term>language semantics</term>
					<term>equational reasoning</term>
					<term>bisimulation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A notional machine is a pedagogical device that abstracts away details of the semantics of a programming language to focus on some aspects of interest. A notional machine should be sound: it should be consistent with the corresponding programming language, and it should be a proper abstraction. This reduces the risk of it introducing misconceptions in education. Despite being widely used in computer science education, notional machines are usually not evaluated with respect to their soundness. To address this problem, we first introduce a formal definition of soundness for notional machines. The definition is based on the construction of a commutative diagram that relates the notional machine with the aspect of the programming language under its focus. Derived from this formalism, we present a methodology for constructing sound notional machines, which we demonstrate by applying it to a series of small case studies. We also show how the same formalism can be used to analyze existing notional machines and find inconsistencies in them as well as propose solutions to these inconsistencies. The work establishes a firmer ground for research in notional machines by serving as a framework to reason about them.</p><p>CCS Concepts: • Social and professional topics → Computing education; • Software and its engineering → Formal language definitions; Context specific languages.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Learning to program involves learning how to express a program in a programming language, but also learning what the semantics of such a program is. For novices, the semantics of a program is often not obviously apparent from the program itself. Instructors then often use a notional machine <ref type="bibr" target="#b18">[Fincher et al. 2020]</ref> to help teach some particular aspect of programs and programming languages, and also to assess students' understanding of said aspect. This aspect is the notional machine's focus. For example, showing expressions as trees (the ExpTree notional machine), as depicted in Figure <ref type="figure">1</ref>, brings out the internal structure of lambda-calculus expressions <ref type="bibr" target="#b26">[Marceau et al. 2011</ref>] and can help to explain the step-by-step evaluation of such expressions. Notional machines are used widely in computer science education:</p><p>Step 2</p><p>Step 1</p><p>Step 0 Figure 1. Evaluation of the term (λt.(λf.t)) a b shown with the notional machine ExpTree. <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> interviewed computer science teachers to build up a dataset of 37 notional machines<ref type="foot" target="#foot_0">1</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Unsound Notional Machines</head><p>Given the extensive use of notional machines, and their intended use as devices to help students when learning, it is important to look at their quality. To begin with, one should make sure that the notional machine is sound: it is faithful to the aspect of programs it is meant to focus on. Anecdotal evidence of using unsound representations in education goes back a long way. In 1960, education pioneer Jerome Bruner wrote that "the task of teaching a subject to a child at any particular age is one of representing the structure of that subject in terms of the child's way of viewing things", that this "task can be thought of as one of translation", but that ideas have to be "represented honestly <ref type="bibr">[. . . ]</ref> in the thought forms of children" <ref type="bibr" target="#b5">[Bruner 1960</ref>]. Bruner's use of the term "honestly" can be seen as a call for soundness of such representations. Decades later, Richard Feynman eloquently stated <ref type="bibr" target="#b17">[Feynman 1985</ref>], after reviewing "seventeen feet" of new mathematics schoolbooks for the California State Curriculum Commission:</p><p>[The books] would try to be rigorous, but they would use examples (like automobiles in the street for "sets") which were almost OK, but in which there were always some subtleties. The definitions weren't accurate. Everything was a little bit ambiguous.</p><p>Ambiguously specified notional machines and notional machines with imperfect analogies to programming concepts are a problem. Educators may mischaracterize language features and students may end up with misconceptions <ref type="bibr" target="#b6">[Chiodini et al. 2021</ref>] instead of profoundly understanding the language.</p><p>Figure 2. The "Array as Row of Spaces in Parking Lot" notional machine captured by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref>.</p><p>For example, <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> describe the "Array as Row of Spaces in Parking Lot" notional machine. Figure <ref type="figure">2</ref> shows part of their card summarizing it. Notice the parallels between the programming language (PL) and the notional machine (NM). Consider Java, a language commonly used in programming courses. In Java, when an array of objects is allocated, all its slots contain null, which means these slots don't contain a reference to any object. This would be reasonably represented in the notional machine as an empty parking lot. But if instead of an array of objects, we have an array of ints, for example, then when we instantiate an array, all its slots contain 0, which is not the absence of a number but a number like any other. A student could also reasonably question whether one can park a car in a slot that is already occupied by another car, or whether one has to remove a car from a spot to park another car in the same spot. In fact, the authors point out that, "the effectiveness of the analogy depends on [...] how well that models the semantics of the programming language. "</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Soundness of Notional Machines via Simulation</head><p>To avoid these issues, we need to make sure that a notional machine is indeed an accurate abstraction. Although the more general view of notional machines as "pedagogic devices to assist the understanding of some aspect of programs or programming" <ref type="bibr" target="#b18">[Fincher et al. 2020</ref>] makes no direct reference to programming languages, programs are expressed in programming languages so we will look at these "aspects of programs" through the lens of how they are realized by some programming language. If a notional machine represents a part of the operational semantics of a programming language, for example, then this representation should be sound, in the sense that steps in the notional machine correspond to steps in the operational semantics of the programming language.</p><p>Showing the soundness of a notional machine amounts to demonstrating that the notional machine simulates (in the sense described by <ref type="bibr" target="#b27">Milner [1971]</ref>) the aspect of programs under the focus of the notional machine. This property can be given in the form of a commutative diagram. Milner's simulation was also used by <ref type="bibr" target="#b22">Hoare [1972]</ref> to establish a definition of the correctness of an 'abstract' data type representation with respect to its corresponding 'concrete' data type representation. <ref type="bibr" target="#b10">Cousot and Cousot [1977]</ref> use a similar commutative diagram to simulate concrete computations in their abstract interpretation framework. This interpretation of simulation also captures the relationship between a notional machine and the underlying programming language because a notional machine is indeed an abstraction of some aspect of interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Contributions</head><p>This paper makes the following contributions:</p><p>• A formal definition of sound notional machine based on simulation (Section 2.1.2). • A methodology for designing notional machines that are sound by construction. It consists of deriving part of the notional machine by leveraging the relationship between the abstract representation of the notional machine and the abstract syntax of the programming language under its focus. We demonstrate the methodology by applying it to a combination of various small programming languages, notional machines, and aspects of programming language semantics (Section 2). • A methodology for analyzing notional machines with respect to their soundness. It consists of modelling the notional machine and the aspect of the programming language under its focus, relating them via simulation. We demonstrate the methodology by analyzing existing notional machines, sometimes pointing out unsoundnesses, and suggesting directions for improvement (Section 3).  <ref type="table">1</ref>. Notional machines, programming languages, and aspects of focus used in Section 2.</p><p>A brief discussion about the distinction between the abstract and concrete representations of a notional machine follows in Section 4. We then evaluate, in Section 5, the entire framework by comparing the notional machines that appeared in Section 2 and Section 3 to an existing dataset of 37 notional machines. We classify the notional machines in the dataset according to various dimensions and show that the notional machines we analyzed are representative of the design space of notional machines used in practice. Section 6 discusses related work and Section 7 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Designing Sound Notional Machines</head><p>We can only begin to talk about the soundness of a notional machine if we have a formal description of the programming language the notional machine is focused on. We use a set of small programming languages with well-known formalizations described in Pierce's Types and Programming Languages (TAPL) book <ref type="bibr" target="#b28">[Pierce 2002</ref>]. The languages are used to explore different aspects of programming language semantics. Table <ref type="table">1</ref> shows the notional machines we use in this section as well as the corresponding programming language and aspect of the semantics of the programming language that the notional machine focuses on. We use the first example also to introduce the definition of soundness for notional machines.</p><p>We model each programming language and notional machine in Haskell. The models are executable, so they include implementations of the programming languages (including parsers, interpreters, and type-checkers), the notional machines, and the relationship between them 2 . The soundness proofs presented in this section are done using equational reasoning <ref type="bibr" target="#b3">[Bird 1989;</ref><ref type="bibr" target="#b19">Gibbons 2002</ref>].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Isomorphic Notional Machines</head><p>As a first straightforward example, let's look at a notional machine for teaching how evaluation works in the untyped lambda-calculus (we will refer to this language as Untyped-Lambda 3 ). While most research papers discuss the lambdacalculus using its textual representation, textbooks sometimes illustrate it using tree diagrams <ref type="bibr">[Pierce 2002, p. 54</ref>]. 2 The artifact containing a superset of the examples in this paper is at 10.5281/zenodo.12609636. 3 The syntax and reduction rules for UntypedLambda are reproduced in the appendix provided as supplementary material .</p><formula xml:id="formula_0">A NM B NM A PL B PL f NM f PL α A α B α B • f PL ≡ f NM • α A (1)</formula><p>Figure <ref type="figure">3</ref>. Soundness condition for notional machines shown as a commutative diagram and in algebraic form.</p><p>We use this as an opportunity to define a simple notional machine which we call ExpTree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Illustrative Example.</head><p>In Figure <ref type="figure">1</ref>, ExpTree is used to demonstrate the evaluation of a specific lambda expression, which happens in two reduction steps. The top of the figure shows the terms in the traditional textual representation of the programming language, while the bottom shows the terms as a tree.</p><p>2.1.2 Soundness via Commutative Diagrams. In general, a notional machine is sound if the diagram in Figure <ref type="figure">3</ref> commutes. We call the commutativity of this diagram the soundness condition for a notional machine. In this diagram, the vertices are types and the edges are functions. We will explain the diagram while instantiating it for this illustrative example (the result of this instantiation is shown in Figure <ref type="figure" target="#fig_0">4</ref>). The bottom layer (A PL , f PL , B PL ) represents the aspect of a programming language 4 we want to focus on. A PL is an abstract representation of a program in that language. In our example, that is the abstract syntax of UntypedLambda (given by the type Term U λ ). The function f PL is an operation the notional machine is focusing on. In our example, that would be step, a function that performs a reduction step in the evaluation of a program according to the operational 4 Although we refer to the bottom layer of the diagram as the programming language layer and we restrict ourselves to analyzing aspects of the syntax and semantics of programming languages, for which we have wellestablished formalizations, that is not an intrinsic restriction of the approach. In principle, the bottom level of the diagram can be whatever aspects of programs or programming the notional machine is focused on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ExpTree</head><p>ExpTree semantics of the language, which in this case also produces a value of type Term U λ .</p><formula xml:id="formula_1">Term U λ Term U λ α • step • α -1 α -1 step α α</formula><p>The top layer of the diagram (A NM , f NM , B NM ) represents the notional machine. A NM is an abstract representation of the notional machine (its abstract syntax). In our simple example, that is a type ExpTree trivially isomorphic to Term U λ via a simple renaming of constructors. The function f NM is an operation on the notional machine which should correspond to f PL . Connecting the bottom layer to the top layer, there are the functions α A and α B from the abstract representation of a program in the programming language to the abstract representation of the notional machine. α is also called an abstraction function.</p><p>Definition 2.1. Given the notional machine (A NM , B NM , f NM :: A NM → B NM ), focused on the aspect of a programming language given by (A PL , B PL , f PL :: A PL → B PL ), the notional machine is sound iff there exist two functions α A :: A PL → A NM and α B ::</p><formula xml:id="formula_2">B PL → B NM such that α B • f PL ≡ f NM • α A .</formula><p>If the abstract representation of the programming language (A PL ) is isomorphic to the abstract representation of the notional machine (A NM ), we can construct an inverse mapping α A</p><formula xml:id="formula_3">-1 such that α A -1 • α A ≡ id ≡ α A • α A -1 .</formula><p>In that case, we can always define a correct-by-construction operation f NM on A NM in terms of an operation f PL on A PL : f NM ::</p><formula xml:id="formula_4">A NM → B NM f NM = α B • f PL • α A -1</formula><p>In such cases, the diagram always commutes and therefore the notional machine is sound: We call these isomorphic notional machines because they are isomorphic to the aspect of the programming language they focus on (a condition sometimes called strong simulation <ref type="bibr" target="#b27">[Milner 1971]</ref>). Of course that's a rather strong condition and not every notional machine is isomorphic so throughout the next sections we will move further away from this simple example, arriving at other instantiations of this commutative diagram.</p><formula xml:id="formula_5">f NM • α A ≡ α B • f PL • α A -1 • α A ≡ α B • f PL<label>(</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Monomorphic Notional Machines</head><p>Notional machines can also serve as the basis for so-called "visual program simulation" <ref type="bibr" target="#b31">[Sorva et al. 2013]</ref> activities, where students manually construct representations of the program execution. This effort often is supported by tools, such as interactive diagram editors, that scaffold the student's activity. Obviously, instructors will want to see their students creating correct representations. However, to prevent students from blindly following a path to a solution prescribed by the tool, the visual program simulation environment should also allow incorrect representations.</p><p>ExpressionTutor<ref type="foot" target="#foot_1">5</ref> is such an educational tool to teach the structure, typing, and evaluation of expressions in programming courses. In ExpressionTutor, students can interactively construct expression tree diagrams given a source code expression. The tool is language agnostic so each node can be freely constructed (by the instructor or the student) to represent nodes of the abstract syntax tree of any language. Nodes can contain any number of holes that can be used to connect nodes to each other. Each hole corresponds to a place in an abstract syntax tree node where an expression would go. Nodes can be connected in a variety of ways, deliberately admitting incorrect structures that not only may not be valid abstract syntax trees of a given programming language but may not even be trees. Even the root node (labeled with a star) has to be explicitly labeled by the student, so it is not guaranteed to exist in every diagram.</p><p>We define the notional machine ExpTutorDiagram, which models the behavior of ExpressionTutor. The fact that Expres-sionTutor allows students to construct incorrect expression tree diagrams means that the abstraction function α is not bijective, as was the case of ExpTree's α. Such incorrect diagrams do not correspond to programs, thus α is deliberately not surjective. Below that are three different incorrect representations students could produce. The left tree collapses the applications (the terms x x) into the enclosing lambda abstraction. The middle tree similarly does this, but it preserves the structure of the lambda abstraction node, while violating the wellformedness of the tree by plugging two children into the same hole. The right tree shows a different problem, where the definition of the name is pulled out of the lambda abstraction and shown as a name use. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Illustrative Example.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Commutative Diagram.</head><p>In general, if the mapping α A , from the abstract representation of the programming language (A PL ) to the abstract representation of the notional machine (A NM ), is an injective but non-surjective function, we can still define the operations on A NM in terms of the operations on A PL . For this we define a function α • A :: A NM → Maybe A PL to be a left inverse of α A such that α • A • α A ≡ return (we use return and fmap to refer to the unit and map operations on monads). Here we modeled the left inverse using a Maybe but another monad could be used, for example, to capture information about the values of type A NM that do not have a corresponding value in A PL . The top-right vertex of the square (B NM ) in this case is the type Maybe B ′ NM and the mapping α B can be implemented in terms of a mapping α ′ B :: B PL → B ′ NM like so:</p><formula xml:id="formula_6">α B :: B PL → B NM α B = return • α ′ B</formula><p>Using the left inverse α • A and α ′ B , we define the operation on A NM as follows:</p><formula xml:id="formula_7">f NM :: A NM → B NM f NM = fmap α ′ B • fmap f PL • α • A</formula><p>This square commutes like so:</p><formula xml:id="formula_8">f NM • α A ≡ { definition of f NM } fmap α ′ B • fmap f PL • α • A • α A ≡ { α • A is left inverse of α A } fmap α ′ B • fmap f PL • return ≡ { third monad law } fmap α ′ B • return • f PL α B • f PL ≡ { definition of α B } return • α ′ B • f PL ≡ { third monad law } fmap α ′ B • return • f PL</formula><p>We can use this result to instantiate the commutative diagram of Figure <ref type="figure">3</ref> for ExpTutorDiagram and Untyped-Lambda, shown in Figure <ref type="figure" target="#fig_4">6</ref>. A PL is defined to be the type ExpTutorDiagram, which essentially implements a graph. Each node has a top plug and any number of holes, which contain plugs. Edges connect plugs. That allows for a lot of flexibility in the way nodes can be connected.</p><p>The ExpressionTutor tool is language agnostic but we can only talk about soundness of a notional machine with respect to some language and some aspect of that language. In this case, we say the tool implements a family of notional machines, each one for a given aspect of focus and a given programming language. We consider here a notional machine focused on evaluation and the programming language again UntypedLambda (denoted again by the type Term U λ ), with f PL equal to step.</p><p>We can always construct a mapping α, from Term U λ to ExpTutorDiagram, because every term t::Term U λ forms a tree and every ExpressionTutor diagram d :: ExpTutorDiagram forms a graph. For each possible term in Term U λ , we need to define a pattern for the content of the corresponding ExpTutorDiagram node which will help the student identify the kind of node. The construction of the left inverse mapping α • ::ExpTutorDiagram → Maybe Term U λ requires more care. We need to make sure that the diagram forms a proper tree and that the pattern formed by the contents of each ExpTutorDiagram node corresponds to a possible Term U λ node, besides making sure that they are connected in a way that indeed corresponds to a valid Term U λ tree.</p><p>In the next section, we construct another commutative diagram where f NM is defined using f PL and a left inverse mapping α • A . To emphasize that point and simplify the diagrams, we will depict the left inverse in the diagram as a dotted line pointing from A NM to A PL (even though α • A is of type A NM → Maybe A PL and not A NM → A PL ) and omit the path via Maybe A PL as shown in Figure <ref type="figure">7</ref>.</p><p>We call these monomorphic notional machines because there is a monomorphism (injective homomorphism) between the notional machine and the aspect of the programming language it focuses on. This is the case here by design, to allow students to make mistakes by constructing wrong diagrams that don't correspond to programs. In general, this will be the case whenever there are values of A NM (the abstract syntax of the notional machine) that have no correspondence in the abstract representation of the language (A PL ). That's often the case in memory diagrams <ref type="bibr">[Dalton and</ref>  </p><formula xml:id="formula_9">Term U λ Term U λ fmap α • fmap step • α • α • step α return • α Figure 7</formula><p>. Simplified version of the commutative diagram for ExpTutorDiagram shown in Figure <ref type="figure" target="#fig_4">6</ref>.</p><p>Luginbuhl 2004] (notional machines used to show the relationship between programs and memory) because they typically allow for the representation of memory states that cannot be produced by legal programs. We show an example of such a notional machine in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">A Monomorphic Notional Machine to Reason About State</head><p>A common use of notional machines is in the context of reasoning about state. In fact, 16 of the 37 notional machines in the dataset by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> focus on either References, Variables, or Arrays (see Section 5). An example of the use of a visual notation to represent state can also be found in TAPL <ref type="bibr">[Pierce 2002, p. 155</ref>]. In Chapter 13 ("References"), the book extends the simply typed lambda-calculus with references (a language we will refer to as TypedLambdaRef 6 ). It explains references and aliasing by introducing a visual notation to highlight the difference between a reference and the cell in the store that is pointed to by that reference. We will refer to this notation, which we will develop into a notional machine, as TAPLMemoryDiagram. In this notation, references are represented as arrows and cells are represented as rounded rectangles containing the representation of the value contained in the cell. Before designing the notional machine, we need to see the context in which this notation is used in the book.</p><p>The book first uses this notation to explain the effect of creating a reference. It shows that when we reduce the term ref 13 we obtain a reference (a store location) to a store 6 The syntax and reduction rules for TypedLambdaRef are reproduced in the appendix provided as supplementary material . cell containing 13. The book then represents the result of binding the name r to such a reference with the following diagram:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="13">r =</head><p>In the book, this operation is written as r = ref 13, but as we will see in the next Section, this form of name binding (name = term) exists only in a REPL-like context which is not part of the language.</p><p>The book continues explaining that we can "make a copy of r" by binding its value to another variable s (with s = r) and shows the resulting diagram:</p><formula xml:id="formula_10">13 r = s =</formula><p>The book then explains that one can verify that both names refer to the same cell by assigning a new value to s and reading this value using r (for example, the term s := 82; !r would evaluate to 82). Right after, the book suggests to the reader an exercise to "draw a similar diagram showing the effects of evaluating the expressions a = {ref 0, ref In a first attempt, let's choose f PL to be an evaluation step and A PL to be modeled as close as possible to the presentation of a TypedLambdaRef program as described in the book. In that case, A PL is the program's abstract syntax tree together with a store, a mapping from a location (a reference) to a value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Problem:</head><p>Beyond the Language. The first challenge is that the name-binding mechanism used in the examples above (written as name = term) exists only in a REPL-like context in the book used for the convenience of referring to terms by name. It is actually not part of the language (TypedLambdaRef) so it is not present in this representation of A PL and as a result it cannot be mapped to A NM (the notional machine). We will avoid this problem by avoiding this name-binding notation entirely and writing corresponding examples fully in the language. The only mechanism actually in the language to bind names is by applying a lambda to a term. Let's see how we can write a term to express the behavior described in the example the book uses to introduce the diagram (shown earlier), where we:</p><p>1. Bind r to the result of evaluating ref 13 2. Bind s to the result of evaluating r 3. Assign the new value 82 to s 4. Read this new value using r Using only the constructs in the language, we express this with the following term:</p><formula xml:id="formula_11">(λr:Ref Nat.(λs:Ref Nat.s := 82; !r) r) (ref 13) 2.3.2 Problem: Direct Substitution.</formula><p>The problem now is that if we model A PL and evaluation as described in the book, the result of reducing a term (λx.t 1 ) t 2 is the term obtained by replacing all free occurrences of x in t 1 by t 2 (modulo alpha-conversion), so we don't actually keep track of name binding information. What we have in A PL at each step is an abstract syntax tree and a store, but we have no information about which names are bound to which values because the names were already substituted in the abstract syntax tree. That would be enough to do Exercise 13.1.1, for example, whose solution is shown in Figure <ref type="figure" target="#fig_5">8</ref>. But the absence of explicit information mapping names to values makes it less suitable to talk about aliasing, because even though a term may contain, at any given point during evaluation, multiple occurrences of the same location, it is not possible to know if these locations correspond to different names, and one may need to trace several reduction steps back to find out when a name was substituted by a location.</p><p>We need to change A PL and step to capture this information, keeping not only a store but an explicit name environment that maps names to values, and only substituting the corresponding value when we evaluate a variable. Like the definition of application in terms of substitution, we have to be careful to avoid variable capture by generating fresh names when needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Illustrative Example.</head><p>Figure <ref type="figure" target="#fig_6">9</ref> shows two variations of the notional machine being used to explain the evaluation of the term we had described before. It shows the state after each reduction step, on the left without an explicit name environment and on the right with an explicit name environment. Between each step, a line with the name of the applied reduction rule is shown. Notice that the representation with a name environment requires extra name lookup steps.</p><p>In both variations, the representation of the program (the term) being evaluated appears first (with gray background). Each term is actually an abstract syntax tree, which we represent here, like in the book, with a linearized textual form. Location terms are represented as arrows starting from where they appear in the abstract syntax tree and ending in the store cell they refer to.</p><p>The naming environment is shown as a table from variable names to terms. Store cells also contain terms. This means the textual representation of terms that appear both inside name environments and inside cells may also contain arrows to other cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.4">Commutative Diagram.</head><p>Similar to the abstract representation of the program execution, the abstract representation of the notional machine contains three parts: one for the program being evaluated, one for the name environment, and one for the store. The type DLocation corresponds to arrow destinations (arrow endpoints). A term is represented as a rose tree of Strings augmented with a case for location.</p><p>The concrete representation of a DTerm can be in linearized text form or as a tree akin to that shown in Section 2.1. The representation of the nodes in a DTerm tree that are TLoc are shown as arrow starting points. These arrows end in the cell corresponding to the DLocation in each TLoc. The concrete representation of the store relates the visual position of each cell with the DLocation of each cell. That leads to the commutative diagram in Figure <ref type="figure">10</ref>, where we use the symbol • M to denote monadic function composition (the fish operator &lt;=&lt; in Haskell).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TAPLMemoryDiagram</head><p>Maybe TAPLMemoryDiagram  <ref type="figure">3</ref> for a notional machine focused on type-checking programs in TypedArith. The notional machine exposes the inner workings of the typing algorithm.</p><formula xml:id="formula_12">(Term U λ , Env U λ , Store U λ ) Maybe (Term U λ , Env U λ , Store U λ ) fmap α • step • M α • α • step α fmap α</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">A Monomorphic Notional Machine to Reason About Types</head><p>So far we have seen examples of commutative diagrams where f PL is step (a function that performs a reduction step) but in principle, f PL could be any operation on A PL that is the focus of a given notional machine. Let's look at an example of notional machine where we do not focus on evaluating but on typing an expression. The language this notional machine focuses on is TypedArith 7 , a language of typed arithmetic expression, which is the simplest typed language introduced in TAPL <ref type="bibr">[Pierce 2002, p. 91</ref>]. We describe two designs.</p><p>In the first design, the data type used for the abstract representation of the notional machine (A NM ) is ExpTutorDiagram, used in Section 2.2. We represent a program in TypedArith with the type Term TyArith and the operation we focus on (f PL ) is typeof :: Term TyArith → Maybe Type TyArith , a function that gives the type of a term (for simplicity we use a Maybe here to capture the cases where a term is not well-typed).</p><p>We then have two abstraction functions: α Term :: Term TyArith → ExpTutorDiagram α Type :: Type TyArith → Type ExpTutor</p><p>The implementation of f TyArith , the notional machine operation (f NM ) that produces a notional machine-level representation of maybe the type of a term, is analogous to what is shown in Figure <ref type="figure">10</ref> because (1) the abstraction function (α Term ) has a left inverse (α • Term ) and (2) f PL produces a Maybe. 7 The syntax and typing rules for TypedArith are reproduced in the appendix provided as supplementary material .</p><p>f TyArith ::</p><formula xml:id="formula_13">ExpTutorDiagram → Maybe Type ExpTutor f TyArith = fmap α Type • typeof • M α • Term</formula><p>As is, a student may benefit from the notional machine's representation of the program's abstract syntax tree and that may be helpful to reason about typing but the notional machine does not expose to the student the inner workings of the process of typing a term.</p><p>The second design, represented in the diagram in Figure <ref type="figure">11</ref>, tackles this issue by enriching the notional machine in a way that allows it to go step-by-step through the typing algorithm. The idea is that f NM now does not produce a type but gradually labels each subtree with its type as part of the process of typing a term. For this, A NM here is TyExpTreeDiagram, which differs from ExpTreeDiagram by adding to each node a possible type label. We still want to write f NM in terms of f PL . The key insight that enables this is to change f PL from typeof to typeof1. The difference between typeof and typeof1 is akin to the difference between big-step and small-step semantics: typeof1 applies a single typing rule at a time. As a result, we have to augment our representation of a program by bundling each term with a possible type (captured in type TyTerm TyArith ). The abstraction function and its left inverse are updated accordingly. The resulting notional machine is depicted in Figure <ref type="figure" target="#fig_8">12</ref>.</p><p>Interestingly, given an expression e, once we label all nodes in the ExpressionTutor diagram of e with their types, the depiction of the resulting diagram is similar to the typing derivation tree of e.  <ref type="table">2</ref>. Notional machines, programming languages, and aspects of focus used in Section 3.</p><p>Note that types are themselves trees but here we're representing them in a simplified form as textual labels because the primary goal of ExpressionTutor is to represent the structure of terms, not the structure of types.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Analyzing Existing Notional Machines</head><p>So far we have seen how we can design sound notional machines by constructing f NM using f PL and functions that convert between A PL and A NM . Now we will analyze existing notional machines, using their informal description to construct all components of the commutative diagram. In particular, here, we have a description of f NM entirely in terms of A NM . We then use property-based testing, using the soundness condition as a property, to uncover unsoundnesses and suggest improvements that eliminate them. Table <ref type="table">2</ref> shows the notional machines we use in this section as well as the corresponding programming language and aspect of the semantics of the programming language that the notional machine focuses on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Debugging a Notional Machine: The Case of Alligator Eggs</head><p>Alligator Eggs<ref type="foot" target="#foot_2">8</ref> is a game conceived by Bret Victor to introduce the lambda-calculus in a playful way. It is essentially a notional machine for the untyped lambda-calculus. The game has three kinds of pieces and is guided by three rules.</p><p>Pieces. The pieces are hungry alligators, old alligators, and eggs. Old alligators are white, while hungry alligators and eggs are colored with colors other than white. The pieces are placed in a plane and their relative position with respect to each other determines their relationship. All pieces placed under an alligator are said to be guarded by that alligator. An alligator together with the pieces that may be guarded by it form a family. Families placed to the right of another family may be eaten by the guardian of the family on the left, depending on the applicability of the gameplay rules. Every egg must be guarded by an alligator with the same color (this must be a hungry alligator because eggs cannot be white).</p><p>Rules. There are three rules that determine the "evolution of families" over time: Eating rule If there is a family guarded by a hungry alligator in the plane and there is a family or egg to its right, then the hungry alligator eats the entire family (or egg) to its right and the pieces of the eaten family are removed. The alligator that ate the pieces dies and the eggs that were guarded by this alligator and that have the same color of this alligator are hatched and are replaced by a copy of what was eaten by the alligator. Color rule Before a hungry alligator A can eat a family B, if a color appears both in A's proteges and in B, then that color is changed in one of the families to another color different from the colors already present in these families. Old age rule If an old alligator is guarding only one egg or one family (which itself may be composed of multiple families), then the old alligator dies and is removed.</p><p>Relation to the Untyped Lambda-Calculus. According to their description, the way Alligator relates to the untyped lambda-calculus is as follows: "A hungry alligator is a lambda abstraction, an old alligator is parentheses, and eggs are variables. The eating rule corresponds to betareduction. The color rule corresponds to (over-cautious) alpha-conversion. The old age rule says that if a pair of parentheses contains a single term, the parentheses can be removed". Although very close, this relation is not completely accurate. We will identify the limitations and propose solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Illustrative Example.</head><p>Figure <ref type="figure" target="#fig_9">13</ref> shows a representation of evaluating the term (λt.(λf.t) a) (λb.b) using the Alligator notional machine.</p><p>Step 0 shows the alligator families corresponding to the term. In the first step, the red alligator eats the family made of the purple alligator and the purple egg. As a result, the eaten family disappears, the red egg guarded by the red alligator hatches and is replaced by the family that was eaten, and the red alligator disappears (dies). In the second step, the grey alligator eats the green egg. As a result, the grey alligator dies and no eggs are hatched because it was not guarding any grey eggs. We are left with the purple family.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Commutative Diagram.</head><p>To build a commutative diagram for Alligator, we need to build the abstract representation of the notional machine A NM , which corresponds to the game pieces and the game board, the abstraction function α :: Term U λ → A NM , and an f NM function, which correspond to the rules that guide the evolution of alligator families. First, we look more precisely at the game pieces and their relationship with Term U λ to model A NM . Eggs An egg corresponds to a variable use and its color corresponds to the variable name. Hungry alligators A hungry alligator somewhat corresponds to a lambda abstraction with its color corresponding to the name of the variable introduced by the lambda (a variable definition) and the pieces guarded by the hungry alligator corresponding to the body of the lambda abstraction. But differently from a lambda abstraction, a hungry alligator does not have to be guarding any pieces, which has no direct correspondence with the lambda calculus because a lambda abstraction cannot have an empty body. Old alligators At first glance, an old alligator seems to correspond to parenthesis. But that is not exactly the case. The lambda abstraction in the term (λt.λf.t) a b requires parentheses because conventionally the body of a lambda abstraction extends as far to the right as possible. However, the corresponding alligator families shown in Figure <ref type="figure" target="#fig_9">13</ref> don't require an old alligator. On the other hand, if we want to represent the term a (b c), then we need an old alligator. Figure <ref type="figure" target="#fig_10">14</ref> shows an example of a term that requires an old alligator. Now let's look at the terms of the untyped lambda-calculus. If hungry alligators are lambda abstractions and eggs are variables then what is an application? Applications are formed by the placement of pieces on the game board. When an alligator family or egg (corresponding to a term t 1 ) is placed to the left of another family or egg (corresponding to a term t 2 ), then this corresponds to the term t 1 applied to t 2 (in lambda calculus represented as t 1 t 2 ).</p><p>Notice that because every egg must be guarded by a hungry alligator with the same color, strictly speaking, an egg cannot appear all by itself. That corresponds to the fact that in the untyped lambda-calculus only lambda terms are values, so a term cannot have unbounds variables. Textbooks, of course, often use examples with unbound variables but these are actually metavariables that stand for an arbitrary term. So, for convenience, we will consider that an egg by itself also forms a family.</p><p>We can then model an alligator family with the type AlligatorFamily, and a game board as simply a list of alligator families. The result is the commutative diagram shown in Figure <ref type="figure" target="#fig_3">15</ref>.</p><formula xml:id="formula_14">data AlligatorFamily = HungryAlligator Color [AlligatorFamily ] | OldAlligator [AlligatorFamily ] | Egg Color</formula><p>The abstraction function α relies on some function (n2c) to map from names to colors. α ::</p><formula xml:id="formula_15">Term U λ → [AlligatorFamily ] α (Var name) = [Egg (n2c name)] α (Lambda name e) = [HungryAlligator (n2c name) (α e)] α (App e1 e2@(App )) = α e1 + + [OldAlligator (α e2)] α (App e1 e2) = α e1 + + α e2</formula><p>From Proof to Property-Based Testing. The commutativity of the diagrams presented in Chapter 2 was demonstrated using equational reasoning. Here instead, we implement the elements that constitute the commutative diagram and use property-based testing to test if the diagram commutes. This approach is less formal and it does not prove the notional machine correct, but it is lightweight and potentially more attractive to users that are not familiar with equational reasoning or mechanised proofs. We will see here that, despite its limitations, this approach can go a long way in revealing issues with a notional machine. The idea is that a generator generates terms t i :: Term U λ and checks that</p><formula xml:id="formula_16">(f NM • α) t i ≡ (α • step) t i .</formula><p>de Bruijn Alligators. The first challenge is that we need to compare values of type [AlligatorFamily ] that were produced using f NM with values produced using step. As we have seen, the colors in AlligatorFamily correspond to variable names but the way step generates fresh names (which then are turned into colors) may be different from the way f NM will generate fresh colors. In fact, the original description of Alligator anticipates the challenge of comparing alligator families. In the description of possible gameplays, they</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[AlligatorFamily ]</head><p>[AlligatorFamily ]</p><formula xml:id="formula_17">Term U λ Term U λ f NM step α α</formula><p>Figure <ref type="figure" target="#fig_3">15</ref>. First attempt at instantiating the commutative diagram in Figure <ref type="figure">3</ref> for the notional machine Alligator.</p><p>clarify that to compare alligator families we need to take into account that families with the same "color pattern" are equivalent. This can be achieved by using a de Bruijn representation [Bruijn 1972] of Alligators. We turn AlligatorFamily into AlligatorFamilyF Color and before comparing families we transform them into AlligatorFamilyF Int following the de Bruijn indexing scheme. The commutative diagram we are moving towards is shown in Figure <ref type="figure" target="#fig_4">16</ref>.</p><p>Evaluation Strategy. With this setup in place, the next step is to implement f NM in terms of the game rules. The eating rule (together with the color rule) somewhat corresponds to beta-reduction but under what evaluation strategy? The choice of evaluation strategy turns out to affect not only the eating rule but also the old age rule. According to the original description, any hungry alligator that has something to eat can eat and one of the original examples shows a hungry alligator eating an egg even when they are under another hungry alligator. That would correspond to a full beta-reduction evaluation strategy but we will stick to a callby-value lambda-calculus interpreter so we will adapt the rules accordingly. The old age rule has to be augmented to trigger the evolution of an old alligator family that follows a topmost leftmost hungry alligator and families under a topmost leftmost old alligator. The eating rule should be triggered only for the topmost leftmost hungry alligator, unless it is followed by an old alligator (in which case the augmented old age rule applies). The color rule plays an important role in the correct behavior of the eating rule as a correspondence to beta-reduction. That's because indeed "the color rule corresponds to (over-cautious) alpha-conversion", so it is responsible for avoiding variable capture.</p><p>With all the rules implemented, we can define a function evolve that applies them in sequence. We will then use evolve in the definition of f NM . One application of evolve corresponds to one step in the notional machine layer but that step does not correspond to a step in the programming language layer. For example, The main action of the old age rule (to remove old alligators) does not have a correspondence in the reduction of terms in UntypedLambda. In terms of simulation theory, in this case the simulation of the programming language by the notional machine is not lock-step. To adapt our property-based testing approach, instead of making f PL equal to step, we will simply reduce the term all the way to a value (leading to the use of eval as f PL in Figure <ref type="figure" target="#fig_4">16</ref>) and correspondingly define f NM to be the successive applications of evolve until we reach a fixpoint. (2) Restricting all colors of hungry alligators in a family to be distinct; (3) Defining colors to correspond to de Bruijn indices instead of names. This means that not only colors wouldn't be repeated in the same family but also that every family would use the same "color scheme" for structurally equivalent terms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Notional Machines for Data Structures</head><p>Although most notional machines focus on the semantics of programming language constructs, some notional machines instead focus on data structures. One such notional machine, which we model in this section, is the "List as Stack of Boxes" (Figure <ref type="figure" target="#fig_12">18</ref>), described by Du Boulay and O'Shea <ref type="bibr">[1976]</ref> and included in the dataset of notional machines analyzed by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref>.</p><p>For notional machines focussing on the dynamic semantics of a language (ExpTree, ExpTree, TAPLMemoryDiagram), the type A PL represents a program in the language under focus (and in the case of TAPLMemoryDiagram, additional information needed to evaluate the program) and the function f PL performs an evaluation step. In the case of TypedExpTutorDiagram, which focusses on type-checking (the static semantics of TypedArith), A PL also represents a program in that language and f PL performed type-checking. Now we will model a notional machine focussing on a data structure, so A PL represents that data structure and there are several f PL functions, one for each operation supported by that data structure. The type A NM can be seen as an abstraction of A PL and it should provide corresponding operations. The commutation of the diagram demonstrates the correctness of this abstraction.</p><p>Modelling "List as Stack of Boxes" requires some adaptations to the original description:</p><p>1. To avoid partiality of the operations typically used to access the head and tail of a list (FIRST and REST in the original description), we define a list using three operations: Empty and Cons to construct a list and uncons :: List a → Maybe (a, List a) to deconstruct it.</p><p>That change also has a covenient representation in the notional machine. 2. In the stack of boxes, each value is shown as a String in a box, which means we can only represent lists of values for which we can create a String representation. 3. The original description wasn't explicit about the representation of an empty list. We need a corresponding empty stack of boxes that can be treated as a stack and not just the absence of boxes. For that we will use a pallet (used to hold boxes in storage). The original description mentions a pallet in two contexts: a. "boxes are stacked on a pallet so that they can be picked up as one stack". That's an important part of the notional machine's behavior but we also need to be able to pick up a box from the top of the stack; b. "The beginning of a list, the top of the stack, is marked with [ and the end of the list, the pallet is marked with ]". Here there's an asymmetry between the end of the list, represented with a pallet, and the beginning of the list, which has no representation in the notional machine. Our denotation of pallet is different: it is the representation of an empty list.</p><p>The result is that we can construct lists either with a pallet or by stacking a box on top of a stack, which must have eventually a pallet at the end. To deconstruct it, we can pick up a box from the top of the stack (pickUp ::</p><formula xml:id="formula_18">Stack → Maybe (Box, Stack)).</formula><p>When trying to pick up a box, either there is only the pallet, in which case we get nothing, or there is a box on top of a stack, in which case we are left with the box and the rest of the stack. The process of formalizing the notional machine, making it precise, once again helped to identify the issues and improve the notional machine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">A Notional Machines for Arrays</head><p>With the techniques we have developed so far, we can turn again to the notional machine "Array as Row of Parking Spaces is Parking Lot", presented in Section 1.1. There we considered Java as the underlying programming language and already identified the first issue, caused by the difference between the representation of arrays of primitive types and arrays of reference types. Here, we will make the notional machine more precise and in the process resolve two problems.</p><p>One approach would be to model the subset of Java needed for the notional machine to work, but Java is a fairly complex language. Instead we start by following the approach taken in the last section: we model the PL layer as an idealized array and the operations it supports. An array supports three operations: allocating an array of a given type and a given length, reading an element at a given index, and writing an element to a given index.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Problem: reference types versus primitive types.</head><p>One of the appeals of the notional machine is that we would represent a newly allocated array of objects as an empty parking lot, because it does not contain "valid" values (their slots contain null). The first issue is that arrays of primitive types are really different in that, when newly allocated, their slots already contain valid values. These arrays would be represented as fully booked parking lots with slots that can never be empty! Here, instead of changing the design of the notional machine, we can use this misfit in the metaphor as a learning opportunity and explicitly discuss it with students. There is still a decision to be made about how exactly the values in the array are going to be represented. We could represent a value as a car with the string representation of the value drawn on its roof, but representing both unboxed and boxed versions of an integer with the same string could be confusing. Instead, we could opt for representing values of reference types as cars of a different color, for example. Of course an array can also contain other arrays, which are themselves objects, and that complicates the picture. Instead, we use the programming language LambdaRef augmented with arrays. We first used this language in Section 2.3, where the TAPLMemoryDiagram notional machine represented all constructs of the language as well as the program's state as it ran (its memory): the store and name environment.</p><p>Here we want to represent only arrays and values so the notional machine layer contains, besides the parking lot, essentially a sequence of statements equivalent to the occurrences of all terms in the program that manipulate arrays (an array allocation, array access, and assignment of a value to an array slot) as they happen when the program runs. This way we can ignore all other terms in the language and aspects of the program's memory as it runs. Besides the information present in the array-manipulating terms themselves, we need one more thing: to be able to uniquely identify each array (e.g. with its location, or address). We annotate each parking lot with the corresponding location (for example using an @ and the location identifier) which we use to identify the parking lot when we write to (or read from) its slots. We can then represent values of reference type using their locations. We could instead use arrows, like we have done in TAPLMemoryDiagram, but that would not work for ref 's because here we are only representing arrays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Abstract vs. Concrete Syntax of Notional Machines</head><p>When reasoning about a notional machine, it's important to distinguish between the data types that represents the notional machine (the information present in A NM and B NM ) and how the notional machine is visualized. This difference is akin to the distinction between the concrete syntax and the abstract syntax of a language. Like a programming language, a notional machine has a concrete and an abstract syntax as well. We also refer to those as concrete and abstract representations of a notional machine. Notice that the concrete representation of a notional machine may not only be a diagram or image that can be depicted on paper but it could also be made of physical objects or enacted with students. In fact, many notional machines are ludic in nature or are built around a metaphor, so the concrete representation of a notional machine is very important.</p><p>Figure <ref type="figure" target="#fig_6">19</ref> shows the different layers at play here. On the programming language side, the parse function converts from the concrete to the abstract syntax of the language. The function α maps from language constructs to notional machine constructs. On the notional machine side, the function toDiagram maps from the abstract representation of the notional machine to its concrete representation, e.g., in the form of an actual diagram. In the case of Alligator, we use the diagrams library <ref type="bibr" target="#b35">[Yates and Yorgey 2015;</ref><ref type="bibr" target="#b36">Yorgey 2012]</ref> to construct the concrete representation so toDiagram produces a value of type Diagram B, where the type parameter B (for Backend) determines the output format of the diagram (e.g. SVG). In fact, the depictions of Alligator Eggs shown here are generated by calls to our artifact that are embedded directly into the paper.</p><p>By decoupling the abstract from the concrete representation, a notional machine can have multiple concrete representations. Alligator Eggs, for example, also describes another concrete syntax that it calls "Schematic Form". This concrete representation is suitable for working with the notional machine using pencil and paper. Figure <ref type="figure" target="#fig_13">20</ref> shows the Church numeral two (the term λf.λx.f (f x)), represented using both concrete representations. In the schematic representation, colors are presented with variable names. An alligator  <ref type="table">3</ref>. Notional machines in the dataset published by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> classified according to their form. is drawn as a line ending with a &lt; for a mouth, and is preceded by a variable name corresponding to its color. An old alligator is drawn with a line without a mouth. An egg is drawn just with the variable name corresponding to its color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Evaluation</head><p>The notional machines we presented not only exemplify how to use our framework to reason about notional machines but also were chosen to be representative of the design space of notional machines used in practice. To characterize this design space we analyzed the notional machines in the dataset collected by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> and classified them according to three dimensions: form, focus, and language construct. For each dimension, we present the categories of the dimension and for each category we show the number of notional machines in that category, the percentage that number represents of the total, and the sections of the paper containing notional machines that fall into that category. The notional machines are often not precesily described so we often had to make assumptions about their characteristics, how they relate to an underlying programming language, and how they are used to teach programming concepts.</p><p>The form (Table <ref type="table">3</ref>) of a notional machine can be metaphorical (primarely inspired by and represented with real world objects) or diagrammatic (represented with diagrams). The distinction between the two is not always clear-cut, given that a notional machine may mix both forms and some real world objects can be represented diagrammatically. Nevertheless, this distinction is useful because metaphorical notional machines may be more difficult to be made sound, given the existing degrees of freedom and constraints of the real world objects they are inspired by. We used our approach to reason about notional machines of the two forms.</p><p>Most notional machines in the dataset focus (Table <ref type="table" target="#tab_4">4</ref>) on the runtime semantics (Evaluation) of a programming language construct (or set of conceptually related constructs) so we further break down these notional machines into the constructs they are primarely focused on (Table <ref type="table">5</ref>). Some entries in the table refer to sets of related constructs. For example, the category Control Flow encompasses constructs like loops and conditional statements, which primarily affect control flow. Here the classification is also not clear-cut, not only because a notional machine may focus on multiple constructs but also because some constructs are related to others. For example, notional machines that focus on functions often (although not always) represent variables as well but only the ones that solely (or primarily) focus on variables are classified as such. The category Misc includes five notional machines each of which focuses on a different construct: String literal, Procedure (side-effecting functions), Objects, Instructions (lower level operations), and one that is not clear from the description. The notional machines we reasoned about using our approach cover the majority of these dimensions.  <ref type="table">5</ref>. Notional machines that focus on evaluation broken down by the set of construct they focus on.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Focus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Expressing Complex Language Semantics</head><p>Although the notional machines presented here as well as in the dataset by <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> focus on aspects of program semantics that one may consider simple, the framework we presented can be used to reason about more complex aspects of program semantics. An example is the conceptual models to reason about Ownership Types in Rust by <ref type="bibr" target="#b11">Crichton et al. [2023]</ref>. The authors present two models: a dynamic and a static one. In our framework, each model can be seen as a notional machine. The authors divide each model into a formal model (about which formal statements can be made), which would correspond to the abstract representation of the notional machine, and an informal model, which would correspond to the concrete representation of the notional machine. In the dynamic model, our PL layer would be the Rust language and our NM layer would be Miri. In the static model, our PL layer would be the polonius model of borrow checking and our NM layer would be the permissions model of borrow checking, introduced by the authors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Related Work</head><p>The term notional machine was coined by <ref type="bibr" target="#b15">Du Boulay [1986]</ref> to refer to "the idealised model of the computer implied by the constructs of the programming language". Therefore it restricts the use of notional machines as means to help understand the runtime behavior of a program or the dynamic semantics of a language. <ref type="bibr" target="#b18">Fincher et al. [2020]</ref>, a working group that included du Boulay, presented a thorough literature review and discussion of the term notional machine and established a broader definition as "pedagogic devices to assist the understanding of some aspect of programs or programming", which includes uses of notional machines as means to help understand the static semantics of a language. The "Expressions as Trees" notional machine, for example, is used for both. We adopt here this broader view of notional machine.</p><p>Another related and important term is conceptual model. <ref type="bibr" target="#b18">Fincher et al. [2020]</ref> states that a "notional machine is effectively a special kind of conceptual model. " That's important because conceptual models, such as the Substitution Model and the Environment Model used in the SICP book (Structure and Interpretation of Computer Programs) <ref type="bibr" target="#b1">[Abelson et al. 1996]</ref>, and SICPJS <ref type="bibr" target="#b0">[Abelson and Sussman 2022]</ref>, for example, are well understood to be essential for reasoning about programs. Notional machines that are sound are indeed conceptual models. The concrete representation of the notional machine can be thought of as embodying the visualization of this conceptual model.</p><p>The idea of simulating or representing a program by means of another program is an old one, and was first studied in detail in the 1970s by <ref type="bibr" target="#b27">Milner [1971]</ref> and <ref type="bibr" target="#b22">Hoare [1972]</ref>. Many of our notional machines illustrate a reduction, stepping, or evaluation 'aspect' of a programming language. Wadler et al.</p><p>[2020] has a nice description of how to relate such reduction systems with simulation, lock-step simulation, and bisimulation. The commutative diagram describing the desired property of a notional machine appears in many places in the literature, and is a basic concept in Category Theory. Closer to our application is its use as 'promotion condition' <ref type="bibr" target="#b2">[Bird 1984;</ref><ref type="bibr" target="#b34">Wang et al. 2013]</ref>.</p><p>Where computing education researchers capture program behavior through notional machines, programming language researchers instead use semantics <ref type="bibr" target="#b25">[Krishnamurthi and Fisler 2019]</ref>. Our work can be seen as a rather standard approach to show the correctness of one kind of semantics of (part of) a programming language, most often the operational semantics, with respect to another semantics, often a reduction semantics. An example of such an approach has been described by <ref type="bibr" target="#b9">Clements et al. [2001]</ref>, whose Elaboration Theorem describes a property that is very similar to our soundness requirement. The lack of a formal approach to showing the soundness of notional machines is also noted by <ref type="bibr" target="#b29">Pollock et al. [2019]</ref>, who develop a formal approach to specifying correct program state visualization tools, based on an executable semantics of the programming language formulated in the K framework <ref type="bibr" target="#b30">[Ros , u and S , erbănută 2010]</ref>. In this paper we study a broader collection of notional machines than just program state visualization tools, and we apply our approach to study the soundness of notional machines.</p><p>Computing educators practitioners use a diverse set of notional machines <ref type="bibr" target="#b18">[Fincher et al. 2020]</ref>. Some notional machines form the basis of automated tools. The BlueJ IDE, which features prominently in an introductory programming textbook <ref type="bibr" target="#b24">[Kölling and Barnes 2017]</ref>, includes a graphical user interface to visualize objects, invoke methods, and inspect object state. PythonTutor <ref type="bibr" target="#b21">[Guo 2013</ref>], an embeddable webbased program visualization system, is used by hundreds of thousands of users to visualize the execution of code written in Python, Java, JavaScript, and other programming languages. UUhistle <ref type="bibr" target="#b32">[Sorva and Sirkiä 2010]</ref>, a "visual program simulation" system, takes a different approach: instead of visualizing program executions, it requires students to perform the execution steps in a constrained interactive environment. When developing such widely used tools, starting from a sound notional machine is essential. <ref type="bibr" target="#b13">Dickson et al. [2022]</ref> discuss the issues around developing and using a notional machine in class. They note, amongst others, "that a notional machine must by definition be correct, but a student's mental model of the notional machine often is not", and that "specifying a notional machine was more difficult than we thought it would be". Our work can help in developing a notional machine, and pointing out flaws in it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>Notional machines are popular in computer science education, commonly used both by instructors in their teaching practice as well as by researchers. Despite their popularity, there has been no precise formal characterization of what should be the relationship between a notional machine and the aspect of the programming language under its focus that would allow one to evaluate whether or not they are consistent with each other. We, therefore, introduced a definition of soundness for notional machines. The definition is based on simulation, a well-established notion widely used in many areas of computer science. Demonstrating soundness essentially amounts to constructing a commutative diagram relating the notional machine with the object of its focus.</p><p>Using this definition, we showed how we can (1) systematically design notional machines that are sound by construction, and (2) analyze existing notional machines to uncover inconsistencies and suggest improvements.</p><p>An important insight in the process is to distinguish between the concrete representation of the notional machine (typically visual) and its abstract representation, about which we can make formal statements. This distinction is akin to the distinction between the concrete and the abstract syntaxes of a programming language.</p><p>We then evaluated how applicable our approach is to notional machines actually used in practice. Using a set of previously published notional machines used in practice, we characterize their design space and show that the notional machines we analyzed using our approach are representative of that design space.</p><p>This work intends more generally to establish a framework to reason about notional machines, placing the research on notional machines on firmer ground. As such, it can be used to address challenges such as the design, analysis, and evaluation of notional machines, and the construction of automated tools based on notional machines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data-Availability Statement</head><p>The artifact implementing the programming languages, notional machines, and the relationship between them as described in the paper is available at 10.5281/zenodo.12609636. The implementation of some of the notional machines also includes a concrete representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Programming Language Definitions</head><p>The programming languages used throughout the paper mostly follows the presentation in the book Types and Programming Languages by <ref type="bibr" target="#b28">Pierce [2002]</ref> with minor changes. In particular, italics are used for metavariables and the axioms in the reduction (evaluation) rules and typing rules are shown with explicitly empty premises.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 UntypedLambda</head><p>Figure <ref type="figure">21</ref> shows the syntax and evaluation rules for the untyped lambda calculus by <ref type="bibr" target="#b7">Church [1936</ref><ref type="bibr" target="#b8">Church [ , 1941]]</ref>, that we have referred to as UntypedLambda. This language is used in Sections 2.1, 2.2, and 3.1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 TypedArith</head><p>We define here the language TypedArith, used in Section 2.4. Figure <ref type="figure">22</ref> shows its syntax and evaluation (reduction) rules and Figure <ref type="figure">23</ref> shows its typing rules. The appeal of using this language to present a notional machine focused on the types is its simplicity. Terms don't require type annotations and the typing rules don't require a type environment. In fact, Pierce uses it as the simplest example of a typed language when introducing type safety.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 TypedLambdaRef</head><p>In Section 2.3, we showed the language TypedLambdaRef, used to design a notional machine that focuses on references. This language is composed of the simply-typed lambda calculus, the TypedArith language, tuples, the Unit type, sequencing, and references. Our goal is again simplicity and this is the simplest language we need for the examples in the book that use the diagram. Figure <ref type="figure" target="#fig_0">24</ref> shows its syntax and evaluation (reduction) rules. We show only the reduction rules for sequencing, references, and tuples because the rules for the rest of the language are similar to what we showed before, except for the store then needs to be threaded through all the rules. Although that is a typed language, we don't present its typing rules because the notional machine in Section 2.3 is focused only on its runtime behavior and not its types.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 4 .</head><label>4</label><figDesc>Figure 4. Instantiation of the commutative diagram in Figure 3 for the notional machine ExpTree and the programming language UntypedLambda.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>2) Instantiating the commutative diagram for ExpTree and UntypedLambda yields the diagram in Figure 4. A dashed line indicates a function that is implemented in terms of the other functions in the diagram and/or standard primitives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Figure 5 uses ExpTutorDiagram to represent the omega combinator. The top shows the textual form on the level of the programming language.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>(Figure 5 .</head><label>5</label><figDesc>Figure 5. The omega combinator in UntypedLambda (top) and (incorrect) representations in ExpTutorDiagram notional machine (bottom).</figDesc><graphic coords="5,130.06,109.96,87.75,72.80" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 .</head><label>6</label><figDesc>Figure 6. Instantiation of the commutative diagram in Figure 3 for the notional machine ExpTutorDiagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 .</head><label>8</label><figDesc>Figure 8. TAPLMemoryDiagram for TypedLambdaRef for TAPL Exercise 13.1.1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 .</head><label>9</label><figDesc>Figure 9. Tracing the evaluation of (λr:Ref Nat.(λs:Ref Nat.s := 82; !r) r) (ref 13) using TAPLMemoryDiagram.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 .Figure 11 .</head><label>1011</label><figDesc>Figure 10. Instantiation of the commutative diagram in Figure 3 for the notional machine TAPLMemoryDiagram and the programming language TypedLambdaRef.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 12 .</head><label>12</label><figDesc>Figure 12. Representation of one step in the notional machine TypedExpTutorDiagram as it types the term if iszero 0 then succ 0 else succ succ 0 in the language TypedArith.</figDesc><graphic coords="10,138.14,72.00,151.20,127.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 13 .</head><label>13</label><figDesc>Figure 13. Evaluation of (λt.(λf.t) a) (λb.b) in the untyped lambda calculus (top) and Alligator notional machine (bottom).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 14 .</head><label>14</label><figDesc>Figure 14. Term (λa.y) ((λb.b) c) requires an old alligator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 16 .Figure 17 .</head><label>1617</label><figDesc>Figure16. Second attempt at instantiating the commutative diagram in Figure3for the notional machine Alligator.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 18 .</head><label>18</label><figDesc>Figure 18. The "List as Stack of Boxes" notional machine as described by Du Boulay and O'Shea [1976].</figDesc><graphic coords="14,55.58,72.00,236.88,171.72" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 20 .</head><label>20</label><figDesc>Figure 20. Multiple concrete representations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Nowwe have all the building blocks of the commutative diagram. We can put them together by running the property-based tests to try to uncover issues in the diagram and indeed we do. According to the eating rule, after eating, a hungry alligator dies and if it was guarding any eggs of the same color, each of those eggs hatches into what was eaten. So the family corresponding to (λa.(λa.a)) t, for example, would evolve to the family corresponding to λa.t instead of λa.a, as shown in Figure17. This issue corresponds to a well-known pitfall in substitution: we cannot substitute bound occurrences of a variable, only the ones that are free.</figDesc><table><row><cell>The issue can be solved in one of the following ways:</cell></row><row><cell>(1) Refining the description of the eating rule, changing</cell></row></table><note><p>3.1.3 Problem: Substitution of Bound Variables. "if she was guarding any eggs of the same color, each of those eggs hatches into what she ate" into "if she was guarding any eggs of the same color that are not guarded by a closer alligator with the same color, each of those eggs hatches into what she ate";</p></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 4 .</head><label>4</label><figDesc>Notional machines in the dataset published by<ref type="bibr" target="#b18">Fincher et al. [2020]</ref> classified according to their focus.</figDesc><table><row><cell cols="2">Num</cell><cell>Perc. Covered</cell></row><row><cell>Evaluation</cell><cell>32</cell><cell>82.05% 2.1 2.2 2.3 3.3 3.1</cell></row><row><cell>Type-checking</cell><cell>2</cell><cell>5.13% 2.4</cell></row><row><cell>Parsing</cell><cell>2</cell><cell>5.13% no</cell></row><row><cell>Data Structure</cell><cell>2</cell><cell>5.13% 3.2</cell></row><row><cell>Logic Gates</cell><cell>1</cell><cell>2.56% no</cell></row><row><cell>Total</cell><cell cols="2">37 100.00% -</cell></row><row><cell>Construct</cell><cell>Num</cell><cell>Perc. Covered</cell></row><row><cell>References</cell><cell cols="2">8 20.51% 2.3</cell></row><row><cell>Functions</cell><cell cols="2">5 12.82% 2.1 2.2</cell></row><row><cell>Variables</cell><cell cols="2">4 10.26% 2.1 2.2 2.3</cell></row><row><cell>Arrays</cell><cell cols="2">4 10.26% 3.3</cell></row><row><cell>Methods</cell><cell>3</cell><cell>7.69% no</cell></row><row><cell>Control Flow</cell><cell>2</cell><cell>5.13% no</cell></row><row><cell>Expressions</cell><cell>1</cell><cell>2.56% 2.1 2.2</cell></row><row><cell>Misc</cell><cell cols="2">5 12.82% no</cell></row><row><cell>Total</cell><cell cols="2">32 82.05% -</cell></row><row><cell>Table</cell><cell></cell><cell></cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0"><p>https://notionalmachines.github.io/notional-machines.html -The website lists 57 items but some of them are part of what they call a notional machine sequence, which we consider a single notional machine.</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>expressiontutor.org</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_2"><p>http://worrydream.com/AlligatorEggs/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="9" xml:id="foot_3"><p>The representation of lists shown in Section 3.2 is not suitable to represent lists that contain lists.</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>We would like to thank <rs type="person">Luca Chiodini</rs> for being a thoughtful critic. This work was partially funded by the <rs type="funder">Swiss National Science Foundation</rs> project <rs type="grantNumber">200021_184689</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_4kvt49B">
					<idno type="grant-number">200021_184689</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Figure <ref type="figure">21</ref>. The untyped lambda calculus (UntypedLambda).    </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Structure and Interpretation of Computer Programs: JavaScript Edition</title>
		<author>
			<persName><forename type="first">Harold</forename><surname>Abelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Jay Sussman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022</date>
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Structure and Interpretation of Computer Programs</title>
		<author>
			<persName><forename type="first">Harold</forename><surname>Abelson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerald</forename><surname>Jay Sussman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julie</forename><surname>Sussman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996">1996</date>
			<biblScope unit="volume">33</biblScope>
		</imprint>
	</monogr>
	<note>Second Edition. second edition ed.</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Promotion and Accumulation Strategies in Transformational Programming</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Bird</surname></persName>
		</author>
		<idno type="DOI">10.1145/1780.1781</idno>
		<ptr target="https://doi.org/10.1145/1780.1781" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="487" to="504" />
			<date type="published" when="1984-10">1984. Oct. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Algebraic Identities for Program Calculation</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">S</forename><surname>Bird</surname></persName>
		</author>
		<idno type="DOI">10.1093/comjnl/32.2.122</idno>
		<ptr target="https://doi.org/10.1093/comjnl/32.2.122" />
	</analytic>
	<monogr>
		<title level="j">Comput. J</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="122" to="126" />
			<date type="published" when="1989-04">1989. April 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Lambda Calculus Notation with Nameless Dummies, a Tool for Automatic Formula Manipulation, with Application to the Church-Rosser Theorem</title>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">G</forename><surname>De Bruijn</surname></persName>
		</author>
		<idno type="DOI">10.1016/1385-7258(72)90034-0</idno>
		<ptr target="https://doi.org/10.1016/1385-7258(72)90034-0" />
	</analytic>
	<monogr>
		<title level="j">Indagationes Mathematicae (Proceedings)</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="381" to="392" />
			<date type="published" when="1972-01">1972. Jan. 1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Process of Education</title>
		<author>
			<persName><forename type="first">Jerome</forename><surname>Bruner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1960">1960</date>
			<publisher>Harvard Univesity Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Curated Inventory of Programming Language Misconceptions</title>
		<author>
			<persName><forename type="first">Luca</forename><surname>Chiodini</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><forename type="middle">Moreno</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Gallidabino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Anya</forename><surname>Tafliovich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">André</forename><forename type="middle">L</forename><surname>Santos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Hauswirth</surname></persName>
		</author>
		<idno type="DOI">10.1145/3430665.3456343</idno>
		<ptr target="https://doi.org/10.1145/3430665.3456343" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1 (ITiCSE &apos;21)</title>
		<meeting>the 26th ACM Conference on Innovation and Technology in Computer Science Education V. 1 (ITiCSE &apos;21)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2021">2021</date>
			<biblScope unit="page" from="380" to="386" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">An Unsolvable Problem of Elementary Number Theory</title>
		<author>
			<persName><forename type="first">Alonzo</forename><surname>Church</surname></persName>
		</author>
		<idno type="DOI">10.2307/2371045</idno>
		<ptr target="https://doi.org/10.2307/2371045jstor" />
	</analytic>
	<monogr>
		<title level="j">American Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page">2371045</biblScope>
			<date type="published" when="1936">1936. 1936</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">The Calculi of Lambda-Conversion</title>
		<author>
			<persName><forename type="first">Alonzo</forename><surname>Church</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1941">1941</date>
			<publisher>Princeton University Press</publisher>
			<biblScope unit="volume">6</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Modeling an Algebraic Stepper</title>
		<author>
			<persName><forename type="first">John</forename><surname>Clements</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><surname>Flatt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Felleisen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Symposium on Programming Languages and Systems (ESOP &apos;01)</title>
		<meeting>the 10th European Symposium on Programming Languages and Systems (ESOP &apos;01)<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="320" to="334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints</title>
		<author>
			<persName><forename type="first">Patrick</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Radhia</forename><surname>Cousot</surname></persName>
		</author>
		<idno type="DOI">10.1145/512950.512973</idno>
		<ptr target="https://doi.org/10.1145/512950.512973" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;77)</title>
		<meeting>the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;77)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="1977">1977</date>
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Grounded Conceptual Model for Ownership Types in Rust</title>
		<author>
			<persName><forename type="first">Will</forename><surname>Crichton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gavin</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<idno type="DOI">10.1145/3622841</idno>
		<ptr target="https://doi.org/10.1145/3622841" />
	</analytic>
	<monogr>
		<title level="j">Proceedings of the ACM on Programming Languages</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">1252</biblScope>
			<date type="published" when="2023-10">2023. Oct. 2023</date>
		</imprint>
	</monogr>
	<note>OOPSLA</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automated Construction of Memory Diagrams for Program Comprehension</title>
		<author>
			<persName><forename type="first">Andrew</forename><forename type="middle">R</forename><surname>Dalton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">William</forename><surname>Kreahling</surname></persName>
		</author>
		<idno type="DOI">10.1145/1900008.1900040</idno>
		<ptr target="https://doi.org/10.1145/1900008" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual Southeast Regional Conference (ACM SE &apos;10)</title>
		<meeting>the 48th Annual Southeast Regional Conference (ACM SE &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2010">2010. 1900040</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Experiences Implementing and Utilizing a Notional Machine in the Classroom</title>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">E</forename><surname>Dickson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brett</forename><forename type="middle">A</forename><surname>Becker</surname></persName>
		</author>
		<idno type="DOI">10.1145/3478431.3499320</idno>
		<ptr target="https://doi.org/10.1145/3478431.3499320" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd ACM Technical Symposium V.1 on Computer Science Education (SIGCSE 2022)</title>
		<meeting>the 53rd ACM Technical Symposium V.1 on Computer Science Education (SIGCSE 2022)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2022">2022</date>
			<biblScope unit="page" from="850" to="856" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Memory Diagrams: A Consistant Approach Across Concepts and Languages</title>
		<author>
			<persName><forename type="first">Toby</forename><surname>Dragon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><forename type="middle">E</forename><surname>Dickson</surname></persName>
		</author>
		<idno type="DOI">10.1145/2839509.2844607</idno>
		<ptr target="https://doi.org/10.1145/2839509.2844607" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th ACM Technical Symposium on Computing Science Education (SIGCSE &apos;16)</title>
		<meeting>the 47th ACM Technical Symposium on Computing Science Education (SIGCSE &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="546" to="551" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Some Difficulties of Learning to Program</title>
		<author>
			<persName><forename type="first">Benedict</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boulay</forename></persName>
		</author>
		<idno type="DOI">10.2190/3LFX-9RRF-67T8-UVK9</idno>
		<ptr target="https://doi.org/10.2190/3LFX-9RRF-67T8-UVK9" />
	</analytic>
	<monogr>
		<title level="j">Journal of Educational Computing Research</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="57" to="73" />
			<date type="published" when="1986-02">1986. Feb. 1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">How to Work the LOGO Machine</title>
		<author>
			<persName><forename type="first">Du</forename><surname>Benedict</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tim O'</forename><surname>Boulay</surname></persName>
		</author>
		<author>
			<persName><surname>Shea</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
		</imprint>
		<respStmt>
			<orgName>Department of Artificial Intelligence, University of Edinburgh</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report 4</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Surely You&apos;re Joking, Mr</title>
		<author>
			<persName><forename type="first">Richard</forename><surname>Feynman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985">1985</date>
			<publisher>Feynman! W. W. Norton</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Notional Machines in Computing Education: The Education of Attention</title>
		<author>
			<persName><forename type="first">Sally</forename><surname>Fincher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Johan</forename><surname>Jeuring</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Craig</forename><forename type="middle">S</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Donaldson</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benedict</forename><surname>Du Boulay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthias</forename><surname>Hauswirth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arto</forename><surname>Hellas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Felienne</forename><surname>Hermans</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Colleen</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andreas</forename><surname>Mühling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Janice</forename><forename type="middle">L</forename><surname>Pearce</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrew</forename><surname>Petersen</surname></persName>
		</author>
		<idno type="DOI">10.1145/3437800.3439202</idno>
		<ptr target="https://doi.org/10.1145/3437800.3439202" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Working Group Reports on Innovation and Technology in Computer Science Education (ITiCSE-WGR &apos;20)</title>
		<meeting>the Working Group Reports on Innovation and Technology in Computer Science Education (ITiCSE-WGR &apos;20)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="21" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Calculating Functional Programs</title>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Gibbons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algebraic and Coalgebraic Methods in the Mathematics of Program Construction: International Summer School and Workshop</title>
		<meeting><address><addrLine>Oxford, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000">2002. April 10-14, 2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<idno type="DOI">10.1007/3-540-47797-7_5</idno>
		<ptr target="https://doi.org/10.1007/3-540-47797-7_5" />
		<editor>Revised Lectures, Roland Backhouse, Roy Crole, and Jeremy Gibbons</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="151" to="203" />
			<pubPlace>Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Online Python Tutor: Embeddable Web-Based Program Visualization for Cs Education</title>
		<author>
			<persName><forename type="first">Philip</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<idno type="DOI">10.1145/2445196.2445368</idno>
		<ptr target="https://doi.org/10.1145/2445196.2445368" />
	</analytic>
	<monogr>
		<title level="m">Proceeding of the 44th ACM Technical Symposium on Computer Science Education -SIGCSE &apos;13</title>
		<meeting>eeding of the 44th ACM Technical Symposium on Computer Science Education -SIGCSE &apos;13<address><addrLine>Denver, Colorado, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page">579</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Proof of Correctness of Data Representations</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">A</forename><surname>Hoare</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00289507</idno>
		<ptr target="https://doi.org/10.1007/BF00289507" />
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="271" to="281" />
			<date type="published" when="1972-12">1972. Dec. 1972</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">CS1 Assessment Using Memory Diagrams</title>
		<author>
			<persName><forename type="first">Mark</forename><forename type="middle">A</forename><surname>Holliday</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Luginbuhl</surname></persName>
		</author>
		<idno type="DOI">10.1145/971300.971373</idno>
		<ptr target="https://doi.org/10.1145/971300.971373" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th SIGCSE Technical Symposium on Computer Science Education (SIGCSE &apos;04)</title>
		<meeting>the 35th SIGCSE Technical Symposium on Computer Science Education (SIGCSE &apos;04)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="200" to="204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Objects First With Java: A Practical Introduction Using BlueJ</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Kölling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><surname>Barnes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017">2017</date>
			<publisher>Pearson</publisher>
		</imprint>
	</monogr>
	<note>th ed.</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Programming Paradigms and Beyond</title>
		<author>
			<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathi</forename><surname>Fisler</surname></persName>
		</author>
		<idno type="DOI">10.1017/9781108654555.014</idno>
		<ptr target="https://doi.org/10.1017/9781108654555.014" />
	</analytic>
	<monogr>
		<title level="m">The Cambridge Handbook of Computing Education Research</title>
		<editor>
			<persName><forename type="first">Anthony</forename><forename type="middle">V</forename><surname>Robins</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">Sally</forename><forename type="middle">A</forename><surname>Fincher</surname></persName>
		</editor>
		<meeting><address><addrLine>Cambridge</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="377" to="413" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Do Values Grow on Trees?: Expression Integrity in Functional Programming</title>
		<author>
			<persName><forename type="first">Guillaume</forename><surname>Marceau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kathi</forename><surname>Fisler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shriram</forename><surname>Krishnamurthi</surname></persName>
		</author>
		<idno type="DOI">10.1145/2016911.2016921</idno>
		<ptr target="https://doi.org/10.1145/2016911.2016921" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Workshop on Computing Education Research -ICER &apos;11</title>
		<meeting>the Seventh International Workshop on Computing Education Research -ICER &apos;11<address><addrLine>Providence, Rhode Island, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page">39</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">An Algebraic Definition of Simulation between Programs</title>
		<author>
			<persName><forename type="first">Robin</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Joint Conference on Artificial Intelligence (IJCAI&apos;71)</title>
		<meeting>the 2nd International Joint Conference on Artificial Intelligence (IJCAI&apos;71)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1971">1971</date>
			<biblScope unit="page" from="481" to="489" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName><forename type="first">Benjamin</forename><forename type="middle">C</forename><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002">2002</date>
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Theia: Automatically Generating Correct Program State Visualizations</title>
		<author>
			<persName><forename type="first">Josh</forename><surname>Pollock</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jared</forename><surname>Roesch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Doug</forename><surname>Woos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zachary</forename><surname>Tatlock</surname></persName>
		</author>
		<idno type="DOI">10.1145/3358711.3361625</idno>
		<ptr target="https://doi.org/10.1145/3358711.3361625" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 ACM SIGPLAN Symposium on SPLASH-E (SPLASH-E 2019</title>
		<meeting>the 2019 ACM SIGPLAN Symposium on SPLASH-E (SPLASH-E 2019<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="46" to="56" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">An Overview of the K Semantic Framework</title>
		<author>
			<persName><forename type="first">Grigore</forename><surname>Ros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Traian</forename><surname>Florin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename></persName>
		</author>
		<idno type="DOI">10.1016/j.jlap.2010.03.012</idno>
		<ptr target="https://doi.org/10.1016/j.jlap.2010.03.012" />
	</analytic>
	<monogr>
		<title level="j">The Journal of Logic and Algebraic Programming</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="397" to="434" />
			<date type="published" when="2010-08">2010. Aug. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Students&apos; Ways of Experiencing Visual Program Simulation</title>
		<author>
			<persName><forename type="first">Juha</forename><surname>Sorva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jan</forename><surname>Lönnberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lauri</forename><surname>Malmi</surname></persName>
		</author>
		<idno type="DOI">10.1080/08993408.2013.807962</idno>
		<ptr target="https://doi.org/10.1080/08993408.2013.807962" />
	</analytic>
	<monogr>
		<title level="j">Computer Science Education</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="207" to="238" />
			<date type="published" when="2013-09">2013. Sept. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">UUhistle: A Software Tool for Visual Program Simulation</title>
		<author>
			<persName><forename type="first">Juha</forename><surname>Sorva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Teemu</forename><surname>Sirkiä</surname></persName>
		</author>
		<idno type="DOI">10.1145/1930464.1930471</idno>
		<ptr target="https://doi.org/10.1145/1930464.1930471" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Koli Calling International Conference on Computing Education Research -Koli Calling &apos;10</title>
		<meeting>the 10th Koli Calling International Conference on Computing Education Research -Koli Calling &apos;10<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="49" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Programming Language Foundations in Agda</title>
		<author>
			<persName><forename type="first">Philip</forename><surname>Wadler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Wen</forename><surname>Kokke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><forename type="middle">G</forename><surname>Siek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Refactoring Pattern Matching</title>
		<author>
			<persName><forename type="first">Meng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jeremy</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kazutaka</forename><surname>Matsuda</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Zhenjiang</forename><surname>Hu</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.scico.2012.07.014</idno>
		<ptr target="https://doi.org/10.1016/j.scico.2012.07.014" />
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="2216" to="2242" />
			<date type="published" when="2013-11">2013. Nov. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Diagrams: A Functional EDSL for Vector Graphics</title>
		<author>
			<persName><forename type="first">Ryan</forename><surname>Yates</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Brent</forename><forename type="middle">A</forename><surname>Yorgey</surname></persName>
		</author>
		<idno type="DOI">10.1145/2808083.2808085</idno>
		<ptr target="https://doi.org/10.1145/2808083.2808085" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd ACM SIGPLAN International Workshop on Functional Art, Music, Modelling and Design</title>
		<meeting>the 3rd ACM SIGPLAN International Workshop on Functional Art, Music, Modelling and Design<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2015">2015. 2015</date>
			<biblScope unit="page" from="4" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Monoids: Theme and Variations (Functional Pearl)</title>
		<author>
			<persName><forename type="first">Brent</forename><forename type="middle">A</forename><surname>Yorgey</surname></persName>
		</author>
		<idno type="DOI">10.1145/2430532.2364520</idno>
		<ptr target="https://doi.org/10.1145/2430532.2364520" />
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="105" to="116" />
			<date type="published" when="2012-09">2012. Sept. 2012</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
